<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Dennis_Chen</title>
	<atom:link href="./index.html" rel="self" type="application/rss+xml" />
	<link>./../../index.html</link>
	<description>杂技程序员</description>
	<lastBuildDate>Wed, 13 Nov 2019 13:30:53 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>
	<item>
		<title>使用Ardunio nano 开发自动小船</title>
		<link>./../2019/11/13/arduino/index.html</link>
				<comments>./../2019/11/13/arduino/index.html#respond</comments>
				<pubDate>Wed, 13 Nov 2019 12:48:40 +0000</pubDate>
		<dc:creator><![CDATA[dennis]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">./../../index.html?p=90</guid>
				<description><![CDATA[]]></description>
								<content:encoded><![CDATA[]]></content:encoded>
							<wfw:commentRss>./../2019/11/13/arduino/feed/index.html</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
		<item>
		<title>yoyo</title>
		<link>./../2019/11/12/yoyo/index.html</link>
				<comments>./../2019/11/12/yoyo/index.html#respond</comments>
				<pubDate>Tue, 12 Nov 2019 11:48:11 +0000</pubDate>
		<dc:creator><![CDATA[dennis]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">./../../index.html?p=64</guid>
				<description><![CDATA[]]></description>
								<content:encoded><![CDATA[]]></content:encoded>
							<wfw:commentRss>./../2019/11/12/yoyo/feed/index.html</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
		<item>
		<title>使用Dijkstra算法，MPI并行编程解决全源最短路径问题（All-Pairs Shortest Paths Problem)</title>
		<link>./../2019/10/24/mpi/index.html</link>
				<comments>./../2019/10/24/mpi/index.html#respond</comments>
				<pubDate>Thu, 24 Oct 2019 07:57:20 +0000</pubDate>
		<dc:creator><![CDATA[dennis]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">./../../index.html?p=72</guid>
				<description><![CDATA[该项目的目标是设计并行算法，并使用Dijkstra算法来解决全源最短路径问题（All-Pairs Shortest Paths Problem) 。 Dijkstra算法mpi 全源最短路径问题： 确定给定图中每对顶点之间的最短图形距离。在全源最短路径问题中，每个顶点到所有顶点的最短距离可以分别计算。因此，MPI框架可用于并行计算最短距离，每个进程负责一部分顶点计算。根据顶点数量和平行比例平均分配所有顶点。在每个进程中，根据当前进程号和进程总数确定每个进程的计算范围。 首先，程序在根进程中读取图形的输入数据，并通过MPI_Bcast函数将图形的顶点数和权重矩阵分配给每个进程。为了方便处理，将图的数据读入并存储在一维数组中。接下来，在每个过程中，使用djkstra算法计算从每个顶点到范围内所有顶点的最短距离。计算完成后，通过MPI_Gatherv函数将每个进程的计算结果收集到根进程中，最后将结果保存到根进程中的文件中。 部分代码 djkstra algorithm 的实现 连续迭代，每次找到距离最短的顶点，更新从该顶点到其他顶点的距离，直到找到到所有顶点到起点的最短距离。这是使用Dijkstra 单源最短路径算法，将此函数broadcast到MPI的其他节点，并分配给其相应的图中的顶点并完成此算法，就可以解决全源最短路径问题。 输入文件 输入文件格式本质上是有向加权图的扁平邻接矩阵。所有权重均为正整数。这些是二进制文件，因此需要将其读取。每个文件包含： 顶点数 (numV) numV x numV 个整数，指定所有连接的权重例如： 对应如下矩阵： 使用 ./run.sh host 文件定义了MPI 所需要的节点数量，最优使用数量在16个左右 输出 ./print_bin_result test_data/xxx.out 项目地址：https://github.com/Dennis174698/dijkstra_mpi]]></description>
								<content:encoded><![CDATA[
<p>该项目的目标是设计并行算法，并使用Dijkstra算法来解决全源最短路径问题（All-Pairs Shortest Paths Problem) 。</p>



<p><a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">Dijkstra算法</a><br><a href="https://en.wikipedia.org/wiki/Message_Passing_Interface">mpi</a>  </p>



<p>全源最短路径问题： 确定给定图中每对顶点之间的最短图形距离。<br>在全源最短路径问题中，每个顶点到所有顶点的最短距离可以分别计算。因此，MPI框架可用于并行计算最短距离，每个进程负责一部分顶点计算。根据顶点数量和平行比例平均分配所有顶点。在每个进程中，根据当前进程号和进程总数确定每个进程的计算范围。</p>



<p>首先，程序在根进程中读取图形的输入数据，并通过MPI_Bcast函数将图形的顶点数和权重矩阵分配给每个进程。为了方便处理，将图的数据读入并存储在一维数组中。接下来，在每个过程中，使用djkstra算法计算从每个顶点到范围内所有顶点的最短距离。计算完成后，通过MPI_Gatherv函数将每个进程的计算结果收集到根进程中，最后将结果保存到根进程中的文件中。</p>



<h2>部分代码</h2>



<p>djkstra algorithm 的实现</p>



<pre class="wp-block-code"><code>/**
 * Using djkstra algorithm to calculate the shortest distance between vertices
 *
 * @param graph Graph struct
 * @param start start number of the vertex that calculates the shortest distance
 * @param end end number of the vertex that calculates the shortest distance
 * @return
 */
int *djstra(Graph *graph, int start, int end) {
    int n = graph->vertices_number;
    int *local_result = (int *) malloc(sizeof(int) * (end - start + 1) * n);
    memcpy(local_result, graph->adjacency_matrix + start * n, (end - start + 1) * n * sizeof(int));
    int *mark = (int *) malloc(sizeof(int) * n);
    int vertex_no = start;
    for (; vertex_no &lt;= end; vertex_no++) {
        memset(mark, 0, sizeof(int) * n);
        int i = 0;
        while (i++ &lt; n) {
            int offset = (vertex_no - start) * n;
            int vertex = get_min(local_result + offset, mark, n);
            mark[vertex] = 1;
            int j = 0;
            for (; j &lt; n; j++) {
                if (mark[j] == 1) {
                    continue;
                }
                // updating distance
                if (local_result[offset + vertex] + graph->adjacency_matrix[vertex * n + j] &lt;local_result[offset + j]) {
                    local_result[offset + j] = local_result[offset + vertex] + graph->adjacency_matrix[vertex * n + j];
                }
            }
        }
    }
    return local_result;
}</code></pre>



<div class="wp-block-image"><figure class="aligncenter"><img src="./../../wp-content/uploads/2019/11/Dijkstra_Animation.gif" alt="" class="wp-image-85"/></figure></div>



<p>连续迭代，每次找到距离最短的顶点，更新从该顶点到其他顶点的距离，直到找到到所有顶点到起点的最短距离。这是使用Dijkstra 单源最短路径算法，将此函数broadcast到MPI的其他节点，并分配给其相应的图中的顶点并完成此算法，就可以解决全源最短路径问题。</p>



<h2>输入文件</h2>



<p>输入文件格式本质上是有向加权图的扁平邻接矩阵。所有权重均为正整数。这些是二进制文件，因此需要将其读取。每个文件包含：</p>



<ul><li>顶点数 (numV)</li><li>numV x numV 个整数，指定所有连接的权重<br>例如：<br></li></ul>



<div class="wp-block-image"><figure class="aligncenter"><img src="./../../wp-content/uploads/2019/11/graph.png" alt="" class="wp-image-79" srcset="./../../wp-content/uploads/2019/11/graph.png 372w, ./../../wp-content/uploads/2019/11/graph-300x217.png 300w" sizes="(max-width: 372px) 100vw, 372px" /></figure></div>



<p>对应如下矩阵：</p>



<div class="wp-block-image"><figure class="aligncenter"><img src="./../../wp-content/uploads/2019/11/matirx.png" alt="" class="wp-image-80"/><figcaption>4 0 15 1 1 0 0 3 0 1 3 0 0 0 1 1 0 </figcaption></figure></div>



<h2>使用</h2>



<p><code>./run.sh</code>  host 文件定义了MPI 所需要的节点数量，最优使用数量在16个左右</p>



<h2>输出</h2>



<p><code>./print_bin_result test_data/xxx.out</code></p>



<p>项目地址：<a href="https://github.com/Dennis174698/dijkstra_mpi">https://github.com/Dennis174698/dijkstra_mpi</a><br></p>
]]></content:encoded>
							<wfw:commentRss>./../2019/10/24/mpi/feed/index.html</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
		<item>
		<title>蚁群算法在旅行商问题的应用</title>
		<link>./../2018/10/20/applying-ant-colony-optimisation-to-the-travelling-salesman-problem/index.html</link>
				<comments>./../2018/10/20/applying-ant-colony-optimisation-to-the-travelling-salesman-problem/index.html#respond</comments>
				<pubDate>Sat, 20 Oct 2018 10:48:08 +0000</pubDate>
		<dc:creator><![CDATA[dennis]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">./../../index.html?p=47</guid>
				<description><![CDATA[Applying Ant Colony Optimisation to the Travelling Salesman Problem problem description 旅行推销员问题：如果旅行推销员希望精确访问一次m个城市列表中的每个城市（其中，从城市i到城市j的旅行成本为cij），然后返回到本国城市，可能的最短路径是多少。 Algorithm Ant Colony Optimization ACO算法基于蚂蚁的行为，尝试寻找两点之间的最佳路径。 这是通过发送大量蚂蚁波来遍历图形来实现的。第一波蚂蚁随机地或基于一种简单的启发式方法（例如从任何节点走最短路径）遍历该图。 然后，信息素会沿着成功的路径分布，那些通过评分函数确定为相对较好的路径将接收更多量的信息素。然后，将进一步的蚂蚁发送出去遍历图，同时考虑信息素的水平和启发式，然后再次将信息素放置在与路径得分成比例的路径上。 这样，最优化的路径将累积最多量的信息素，并且更有可能被后代的蚂蚁选择。 Implementation 迭代阶段涉及迭代一定数量的世代，并在每次迭代中执行以下操作： 为每个蚂蚁生成一条路线。该路线由以下步骤生成： a. 随机选择一个起点 b. 根据信息素图和启发式因素的组合选择下一个要访问的位置。具体来说，使用以下公式为每个未访问的位置评分： 𝑠𝑐𝑜𝑟𝑒 = 𝑝ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒𝛼**α ∗ ℎ𝑒𝑢𝑟𝑖𝑠𝑡𝑖𝑐**β 同时: 𝑝ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒 = 从当前位置到未访问位置的路径上的信息素数量。 α = 信息素权重影响的比例因子。 ℎ𝑒𝑢𝑟𝑖𝑠𝑡𝑖𝑐 = 从当前位置到未访问位置的启发式值（在此解决方案中为1 /距离）。 β = 启发值权重影响的比例因子. c. 将下一个位置添加到路线并将其从未访问位置列表中删除。 根据行进的总距离对路线进行评分。 (cost= fun.decodingFun(RouteData,popsize,dmat,N)) 当找到更好的路线，将bestsolution更新 将分数标准化到 [100, 200]。 &#8230; <p class="link-more"><a href="./../2018/10/20/applying-ant-colony-optimisation-to-the-travelling-salesman-problem/index.html" class="more-link">Continue reading<span class="screen-reader-text"> "蚁群算法在旅行商问题的应用"</span></a></p>]]></description>
								<content:encoded><![CDATA[
<h1>Applying Ant Colony Optimisation to the Travelling Salesman Problem</h1>



<h2>problem description</h2>



<p>旅行推销员问题：如果旅行推销员希望精确访问一次m个城市列表中的每个城市（其中，从城市i到城市j的旅行成本为cij），然后返回到本国城市，可能的最短路径是多少。</p>



<h2>Algorithm</h2>



<figure class="wp-block-image"><img src="https://github.com/Dennis174698/TSP/raw/master/aco.png" alt=""/></figure>



<p style="font-size:27px">Ant Colony Optimization</p>



<p>ACO算法基于蚂蚁的行为，尝试寻找两点之间的最佳路径。</p>



<p>这是通过发送大量蚂蚁波来遍历图形来实现的。第一波蚂蚁随机地或基于一种简单的启发式方法（例如从任何节点走最短路径）遍历该图。</p>



<p>然后，信息素会沿着成功的路径分布，那些通过评分函数确定为相对较好的路径将接收更多量的信息素。然后，将进一步的蚂蚁发送出去遍历图，同时考虑信息素的水平和启发式，然后再次将信息素放置在与路径得分成比例的路径上。</p>



<p>这样，最优化的路径将累积最多量的信息素，并且更有可能被后代的蚂蚁选择。</p>



<p><br></p>



<h2>Implementation</h2>



<figure class="wp-block-image"><img src="https://github.com/Dennis174698/TSP/raw/master/workflow1.png" alt=""/></figure>



<p> <br>   迭代阶段涉及迭代一定数量的世代，并在每次迭代中执行以下操作： <br></p>



<ol><li>为每个蚂蚁生成一条路线。该路线由以下步骤生成：<br><br> <strong>a. </strong>随机选择一个起点<br><br> <strong>b. </strong>根据信息素图和启发式因素的组合选择下一个要访问的位置。具体来说，使用以下公式为每个未访问的位置评分： <br> <code>𝑠𝑐𝑜𝑟𝑒 = 𝑝ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒𝛼**α ∗ ℎ𝑒𝑢𝑟𝑖𝑠𝑡𝑖𝑐**β</code> 同时:  <code>𝑝ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒</code> = 从当前位置到未访问位置的路径上的信息素数量。<br><br> <code>α</code> = 信息素权重影响的比例因子。 <br><br> <code>ℎ𝑒𝑢𝑟𝑖𝑠𝑡𝑖𝑐</code> = 从当前位置到未访问位置的启发式值（在此解决方案中为1 /距离）。<br><br> <code>β</code> = 启发值权重影响的比例因子.<br><br> c. 将下一个位置添加到路线并将其从未访问位置列表中删除。<br></li><li>根据行进的总距离对路线进行评分。       <code>(cost= fun.decodingFun(RouteData,popsize,dmat,N))</code><br></li><li>当找到更好的路线，将bestsolution更新<br></li><li>将分数标准化到 [100, 200]。<br></li><li>生成信息素图，以沿着蚂蚁的路线分布。该值由路径上每条路径的信息素<code>𝑞 / 𝑠𝑐𝑎𝑙𝑒𝑑 𝑠𝑐𝑜𝑟𝑒</code>决定，其中q是某个比例因子<br></li><li>衰减现有信息素并使用以下公式添加所需的新信息素：<br><code>𝑝ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒 = 𝑐𝑢𝑟𝑟𝑒𝑛𝑡𝑃ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒 ∗ (1 − ⍴) + 𝑛𝑒𝑤𝑃ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒(Tau=Tau*(1-rho)+detaTau)</code><br><code>𝑝ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒</code> = 更新后的信息素值<br><code>𝑐𝑢𝑟𝑟𝑒𝑛𝑡𝑃ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒</code> = 在这条路线上现有的信息素值<br><code>⍴ </code>=信息素衰减因子.<br><code>𝑛𝑒𝑤𝑃ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒</code> = 根据路线分数添加的信息素.<br></li></ol>



<p>所有迭代完成后， 将会得到：</p>



<ol><li>最优路线</li><li>每次迭代的最优分数</li><li>在每次迭代中所有路线分数的总和</li></ol>



<p style="font-size:29px">Sample Result:</p>



<p>预设值</p>



<p>MaxGen=100 #Iteration<br> popsize=20 #population of ants<br> alpha=4    #α<br> beta=1     #β<br> rho=0.5    #ρ<br> Q=5        #q</p>



<ul class="wp-block-gallery columns-2 is-cropped"><li class="blocks-gallery-item"><figure><img src="./../../wp-content/uploads/2019/11/1.png" alt="" data-id="54" data-link="./../2018/10/20/%e8%9a%81%e7%be%a4%e7%ae%97%e6%b3%95%e5%9c%a8%e6%97%85%e8%a1%8c%e5%95%86%e9%97%ae%e9%a2%98%e7%9a%84%e5%ba%94%e7%94%a8/attachment/1/index.html" class="wp-image-54" srcset="./../../wp-content/uploads/2019/11/1.png 432w, ./../../wp-content/uploads/2019/11/1-300x200.png 300w" sizes="(max-width: 432px) 100vw, 432px" /></figure></li><li class="blocks-gallery-item"><figure><img src="./../../wp-content/uploads/2019/11/2.png" alt="" data-id="55" data-link="./../2018/10/20/%e8%9a%81%e7%be%a4%e7%ae%97%e6%b3%95%e5%9c%a8%e6%97%85%e8%a1%8c%e5%95%86%e9%97%ae%e9%a2%98%e7%9a%84%e5%ba%94%e7%94%a8/attachment/2/index.html" class="wp-image-55" srcset="./../../wp-content/uploads/2019/11/2.png 432w, ./../../wp-content/uploads/2019/11/2-300x200.png 300w" sizes="(max-width: 432px) 100vw, 432px" /></figure></li></ul>



<p>项目地址：<a href="https://github.com/Dennis174698/TSP">https://github.com/Dennis174698/TSP</a></p>
]]></content:encoded>
							<wfw:commentRss>./../2018/10/20/applying-ant-colony-optimisation-to-the-travelling-salesman-problem/feed/index.html</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
	</channel>
</rss>
